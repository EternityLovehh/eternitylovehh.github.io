---
title: jvm相关
date: 2021-03-04 18:07:19
tags: java
categories:
top_img:
cover:
---

jvm即Java虚拟机，是用于运行Java程序编译后的字节码文件。java程序经过一次编译之后，将java代码编译为字节码也就是.class文件，然后不同的操作系统依靠不同的java虚拟机解释器进行解释，最后转换成不同平台的机器码。

### jvm内存结构

java程序执行过程中，内存会被划分为不同的数据区域，各个区域有各自的用途

![img](https://pics7.baidu.com/feed/1c950a7b02087bf4600fcdb16c143b2a13dfcfd1.jpeg?token=1b629473555dd856ff2d9ca3301b37ea)

#### 程序计数器

当前线程所执行的字节码的行号指示器，用于记录正在执行的虚拟机字节指令地址，线程私有

#### java虚拟栈

存放基本数据类型、对象的引用、方法出口等，线程私有，生命周期和线程相同，线程私有

#### 本地方法栈

本地方法栈和Java虚拟机栈非常类似，他们最大的不同在于，java虚拟机栈用于java方法的调用，而本地方法栈用于Native方法的调用，线程私有

#### 堆

java堆是所有线程共享的一块内存区域，在虚拟机启动时创建，java内存最大的一块，所有对象实例、数组都存在放java堆，GC回收的地方，线程共享

#### 方法区

存放已被加载的类信息、常量、静态变量、即时编译的代码数据等，jdk8以前用“永久代”来实现方法区，可以用 -XX:MaxPermSize 来设置永久代大小，有内存溢出的风险，所以jdk8以后用元空间实现方法区。元空间与永久代之间的区别是，永久代是堆的一部分，和新生代，老年代的地址是连续的，元空间不在虚拟机中，而属于本地内存，默认情况下，元空间的大小仅受本地内存限制。

### jvm内存模型

java堆和方法区是多个线程共享的数据区域，多个线程可以操作对堆和方法区中的同一个数据，java线程间通过共享内存进行通信

![img](https://upload-images.jianshu.io/upload_images/845143-171be58948f37fcc.png?imageMogr2/auto-orient/strip|imageView2/2/w/423/format/webp)

java内存模型简称JMM，它不像jvm内存结构一样真实存在，而是一个抽象的概念。java多线程对共享内存进行操作的时候会存在一些如可见性，原子性和顺序性的问题，JMM是围绕着多线程通信及相关的一些特性而建立的模型。JMM定义了一些语法集，这些语法集映射到java语言的volatile、synchronized等关键字。

#### 类加载机制

jvm的类加载机制，规定一个类有且只有一个类加载器对它进行加载。

虚拟机把类的数据从class文件加载到内存，并对数据进行校验，转换解析和初始化，最终形成可以被虚拟机直接使用的java类型的过程，整个生命周期包括七个阶段

![img](E:\github\myblog\source\images\1900685-5b9f351d3bc5b208.png)

### 类加载器

虚拟机默认提供了三种类加载器，启动类加载器、扩展类加载器、应用程序类加载器。

### 双亲委派模型

双亲委派模型要求除了顶层的启动类加载器外，其余类加载器都应该有自己的父类加载器（类加载器之间的父子关系不是以继承的关系实现，而是使用组合关系来复用父加载器的代码）

#### 1. 工作原理

如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层级的类加载器都是如此，因此所有请求都会被传到最顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求时，子加载器才会尝试自己去加载。

#### 2. 优点

（1）使java类跟类加载器一起具备了一种带有优先级的层次关系

（2）避免类的重复加载，当父类加载器已经加载了该类时，子类加载器就没必要再加载一次

（3）解决各个类加载器的基础类统一问题，越基础的类由越上层的加载器进行加载避免java核心api中的类被随意替换

### jvm垃圾回收机制

垃圾回收机制是回收堆内存中的对象，栈中的对象是不需要回收机制去考虑的，判断一个对象是否应该被回收，要去判断对象是否存在引用关系

#### 引用计数法 

此对象有一个引用，即增加一个计数，删除一个引用则减少一个计数，垃圾回收时，只需要收集计数为0的对象。无法处理循环引用问题

#### 可达性分析

可达性分析的基本思路是通过一系列可以作为root的对象作为起始点，从这些节点开始向下搜索，当一个对象到root节点没有任何引用连接时，则证明此对象是可以被回收的

### jvm垃圾回收算法

#### 标记清除算法

分为两个阶段：标记阶段和清除阶段，标记阶段找出所有需要被回收的对象并作出标记，清除阶段是回收被标记的对象所占用的空间。容易产生内存碎片

#### 复制算法

首先将可用内存空间按照大小平均分为两部分，在使用时只使用其中的一部分，另一部分不使用。当其中一部分满了之后，触发收集机制，将还存活的对象复制到另一块内存上面，然后把当前内存的空间一次清理掉，这样就不容易出现内存碎片了。

#### 标记整理算法

该算法结合了标记清除和复制算法，分为两个阶段，第一阶段，先标记出待回收的对象，第二阶段，不是直接清除可回收对象，而是将存活对象都向一段移动，然后清理掉回收的内存。

#### 分代回收算法

根据对象存活的生命周期将内存划分为若干个不同的区域，不同生命周期对象放在不同代上，对于不同代采用最适合的算法进行垃圾回收。